# 적용 사례 2
앞서 적은 GroupA 하위에 ItemB, ItemC 말고도 ItemD라는 개념이 있는데 이번에 ItemD에 doSomething 기능을 구현하게 됐다. ItemDClass에 doSomething 기능을 위한 로직을 개발해야 하고 GroupA 클래스 doSomethingA()메서드 안에 doSomething itemD 로직을 추가해야 했다.

우선 앞선 시도에서 잘못된 점을 먼저 짚고 넘어가보자
## 아쉬웠던 점과 개선사항
### 1. 코드 재사용 부분에서 기대했던 것 만큼 효과를 보기 어려웠다.
**GroupAClass** 안에 do something itemB, do something itemC 관련 메서드를 만들고 ItemBClass, ItemCClass 에서 사용해보려 했으나 그러지 못했다.
### 2. 리팩토링한 코드를 신뢰할 수가 없었다.
이건 말 그대로 정말 내가 리팩토링 한 코드를 신뢰할 수가 없었다. 
## 리팩토링 목표
* 코드 재사용성을 높여 중복 코드를 줄여보자
* 응집도 높고 결합도가 적도록 설계해 보자
* 구체 클래스 보단 추상 클래스에 의존을 할 수 있도록 하자
* 의존성을 숨기지 말자. 되도록이면 외부에서 의존성을 주입하여 사용하자
* 리팩토링 후 단위테스트를 해보자
## 실행계획
### 코드 재사용성을 높여 중복 코드를 줄여보자
ItemBClass, ItemCClass, ItemDClass는 모두 비슷한 로직. GroupAClass는 ItemBClass, ItemCClass, ItemDClass 로직을 포함한다. 모든 클래스는 세부적인 로직은 다르지만 동일한 행위를 한다. 그래서 template method 패턴을 사용하면 적절할 것 같았고, 이 패턴을 사용하였다.
### 응집도 높고 결합도가 적도록 설계해 보자
결합도를 낮추기 위해 클래스 안에서 다른 객체가 필요한 경우 외부에서 주입해 주는 방식을 사용하였다. 응집도 관련해서는 doSomething 메서드 관련 부분만 클래스를 따로 떼어내어 GroupA, ItemB, ItemC, ItemD 클래스에 각각 구현을 하여서 어느 정도 응집도를 높일 수 있었다.
## 구체 클래스 보단 추상 클래스에 의존을 할 수 있도록 하자
이 부분은 많이 신경을 못썼다. 
### 의존성을 숨기지 말자
내부에서 객체를 생성하지 않고 생성자에서 필요한 객체를 의존성을 주입하여 사용하였다.
### 리팩토링 후 단위테스트를 해보자

## 적용 방식
ItemBClass, ItemCClass 의 doSomethingB, doSomethingC 메서드는 로직이 거의 동일하다. 새로 개발해야 하는 ItemDClass의 doSomethingD도 마찬가지로 개발해야 하는 로직이 거의 비슷 하다. 이 점에 착안하여 template method 패턴을 떠올렸고 적용해보기로 했다.

처음 구상한 구조는 아래와 같다. 

![클래스다이어그램]()

deploy라는 public interface를 가지는 DeployItem 추상클래스를 만들고 Package, Part, Component 에 관련된 로직은 각각 DeployItem 상속받아 구현하였다.

구현 완료 하고 JobService 클래스에 적용하려 했으나 DeployItem의 deploy 로직에 조금 더 세분화가 필요했다.