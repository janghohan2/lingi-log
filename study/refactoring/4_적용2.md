# 적용 사례 2
앞서 적은 GroupA 하위에 ItemB, ItemC 말고도 ItemD라는 개념이 있는데 이번에 ItemD에 doSomething 기능을 구현하게 됐다. ItemDClass에 doSomething 기능을 위한 로직을 개발해야 하고 GroupA 클래스 doSomethingA()메서드 안에 doSomething itemD 로직을 추가해야 했다.

앞선 시도가 성공적이진 않았지만 그 경험을 바탕으로 아쉬웠던 점을 보완해서 이번 개발에 적용해 보려 한다. 우선 앞선 시도에서 아쉬웠던 점을 먼저 짚고 넘어가보자
## 아쉬웠던점
1. 코드 재사용 부분에서 기대했던 것 만큼 효과를 보기 어려웠다.
    * **GroupAClass** 안에 do something itemB, do something itemC 관련 메서드를 만들고 ItemBClass, ItemCClass 에서 사용해보려 했으나 그러지 못했다.
2. 리팩토링한 코드를 신뢰할 수가 없었다.
    * 이건 말 그대로 정말 내가 리팩토링 한 코드를 신뢰할 수가 없었다. 

크게 두 가지가 있었다. 이 두가지와 지금 읽고있는 Object라는 책을 바탕으로 새로운 원칙을 세워 봤는데
## 새로운 원칙
* 코드 재사용성을 높여 중복 코드를 줄여보자
* 응집도 높고 결합도가 적도록 설계해 보자
* 구체 클래스 보단 추상 클래스에 의존을 할 수 있도록 하자
* 의존성을 숨기지 말자. 되도록이면 외부에서 의존성을 주입하여 사용하자
* 리팩토링 후 단위테스트를 해보자

이렇게 다섯개로 정해봤다. 회사 소스를 올릴 수 없어 간략하게 텍스트로 설명을 해야 할 것같다. 각 목표를 어떻게 적용하였는지 설명을 해보면 아래와 같다.
## 적용 방식
원칙|적용방식
-|-
1. 코드 재사용성을 높여 중복 코드를 줄여보자|ItemBClass, ItemCClass, ItemDClass는 모두 비슷한 로직. GroupAClass는 ItemBClass, ItemCClass, ItemDClass 로직을 포함한다.<br>모든 클래스는 세부적인 로직은 다르지만 동일한 행위를 한다. 그래서 template method 패턴을 사용하면 적절할 것 같았고, 이 패턴을 사용하였다.
2. 응집도 높고 결합도가 적도록 설계해 보자|결합도를 낮추기 위해 클래스 안에서 다른 객체가 필요한 경우 외부에서 주입해 주는 방식을 사용하였다.<br>응집도 관련해서는 doSomething 메서드 관련 부분만 클래스를 따로 떼어내어 GroupA, ItemB, ItemC, ItemD 클래스에 각각 구현을 하여서 어느 정도 응집도를 높일 수 있었다.
3. 구체 클래스 보단 추상 클래스에 의존을 할 수 있도록 하자|Template Method 패턴을 사용했으므로 추상클래스 타입을 선언하고 구체클래스를 생성하여 사용하면 된다.
4. 의존성을 숨기지 말자|내부에서 객체를 생성하지 않고 생성자에서 필요한 객체를 의존성을 주입하여 사용하였다.
5. 리팩토링 후 단위테스트를 해보자|테스트 코드를 작성하는 데 조금 애를 먹었다. 변명하자면 나 스스로도 junit에 익숙하지 않았고 회사 동료들도 junit을 사용해본 사람이 없었다.<br>또한 Struts2 프레임워크를 사용하고 있는데 예제코드를 찾기도 어려웠다... 그래서 단위테스트를 하나하나 진행하진 못했고 전체 기능이 잘 돌아가는지 정도만 테스트를 했다.
## 결과
지금까지 글로만 봐왔던 개념들을 실제로 사용해볼수 있는 기회였다. 새로운 구조가 정말로 변경에 유연하게 대처할 수 있을지는 실제로 변경이 일어나봐야 알겠지만 일단 확실한건 읽기쉽고 이해하기 쉬운 코드가 됐다. 긴 메서드를 기능별로 작은 메서드들로 분리를 하였고, 여러 클래스간 중복되는 코드들을 재사용 하였다. 그리고 기능에 대한 알고리즘을 정의함으로써(템플릿메서드패턴 사용) 전체적인 흐름을 따라가기가 쉬워졌다(고 생각한다..).

개발 완료하고 팀원들과 리뷰하는 시간을 가졌고 대부분 긍정적인 반응을 보여줬다. 이런 노력이 처음 이뤄졌다고 하는 말을 듣고 뭔가 복잡한 생각이 들긴 했지만 어쨌든 나는 보기좋고 읽기좋고 유지보수하기 좋은 코드를 위한 자발적인 노력을 앞으로도 계속해나가려 한다.